'use strict';

import ws, { WebSocketServer } from 'ws';
import { readdirSync } from 'node:fs';
import { resolve } from 'node:path';

/**
 * Class that manages the websocket server.
 * @class WebsocketManager
 * @extends {WebSocketServer}
 */
class WebsocketManager extends WebSocketServer {
  /**
   * @param {Object} [server] Reserved parameter for the http server.
   */
  constructor(server) {
    super({ server });
    
    /**
     * @type {Object}
     */
    this.intervalPing = this.startIntervalPing();
    /**
     * Variable containing all the handlers of requests made via websocket.
     * @type {Object}
     */
    this.handlers = this.resolveHandlers();
    
    /* Event fired after websocket server starts. */
    this.on('connection', (client, req) => {
      /**
       * Variable containing the information whether the client is connected or not.
       * @type {Boolean}
       */
      client.isAlive = true;
      /* Loading client events. */
      client
        .on('pong', () => (client.isAlive = true))
        .on('message', this.message.bind(this));
        
      /**
       * Function used to send information to a websocket client.
       * @type {Function}
       * 
       * @example
       * ```js
       * client._send('ready', 'Welcome to the websocket server!');
       * ```
       * 
       * @return {Boolean}
       */
      Object.defineProperty(client, '_send', {
        value: function Send(op, data) {
          return new Promise((res, rej) => {
            this.send(JSON.stringify({ op, data }), null, (error) => {
              if (error) return rej(error);
              return res(true);
            });
          });
        }
      });
    });
  }
  
  /**
   * Function whose functionality is to manage all messages received via websocket.
   * 
   * @param {Object} [message] Message received via websocket.
   * @param {Boolean} [isBinary] Value identifying whether the value is binary or not.
   * 
   * @return {Undefined}
   */
  message(message, isBinary) {
    if (Array.isArray(message)) message = Buffer.concat(message);
    else if (message instanceof ArrayBuffer) message = Buffer.from(message);
    
    message = JSON.parse(message);
    if (!('op' in message) || !(message.op.toLowerCase() in this.handlers)) return;
    this.handlers[message.op.toLowerCase()](this, message);
  }
  
  /**
   * This function is the part of loading all the handlers of requests made via websocket.
   * @return {Object}
   */
  async resolveHandlers() {
    let url = import.meta.url, handlers = {},
      dirname = url.slice(7, url.lastIndexOf('/'));
      
    /* Loading the handles... */
    for (let file of readdirSync(resolve(dirname, 'handlers'))) {
      if (!file.endsWith('.js')) continue;
      let handler = (await import(`./handlers/${file}`)).default;
      handlers[file.split('.')[0].toLowerCase()] = handler;
    }
    
    return handlers;
  }
  
  /**
   * This function does the part of pinging websocket clients.
   * @return {Object}
   */
  startIntervalPing() {
    return setInterval(() =>
      this.clients.forEach(client => {
        if (!client.isAlive) return client.terminate();
        
        client.isAlive = false;
        return client.ping();
      })
    , 3e4); // 30 seconds
  }
}

export default WebsocketManager;