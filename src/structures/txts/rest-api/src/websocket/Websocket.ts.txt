'use strict';

import ws, { WebSocketServer } from 'ws';
import { readdirSync } from 'node:fs';
import { resolve } from 'node:path';

/**
 * Class that manages the websocket server.
 * @class WebsocketManager
 * @extends {WebSocketServer}
 */
class WebsocketManager extends WebSocketServer {
  public intervalPing: object;
  public handlers: object;
  
  /**
   * @param {object} [server] Reserved parameter for the http server.
   */
  constructor(server: object) {
    super({ server });
    
    /**
     * @type {object}
     */
    this.intervalPing = this.startIntervalPing();
    /**
     * Variable containing all the handlers of requests made via websocket.
     * @type {object}
     */
    this.handlers = this.#resolveHandlers();
    
    /* Event fired after websocket server starts. */
    this.on('connection', (client, req) => {
      /**
       * Variable containing the information whether the client is connected or not.
       * @type {boolean}
       */
      client.isAlive = true;
      /* Loading client events. */
      client
        .on('pong', () => (client.isAlive = true))
        .on('message', this.#message);
        
      /**
       * Function used to send information to a websocket client.
       * 
       * @type {function}
       * @returns {boolean}
       * 
       * @example
       * ```js
       * client._send('ready', 'Welcome to the websocket server!');
       * ```
       */
      Object.defineProperty(client, '_send', {
        value: function Send(op, data) {
          return new Promise((res, rej) => {
            this.send(JSON.stringify({ op, data }), null, (error) => {
              if (error) return rej(error);
              return res(true);
            });
          });
        }
      });
    });
  }
  
  /**
   * Function whose functionality is to manage all messages received via websocket.
   * 
   * @param {object} [message] Message received via websocket.
   * @param {boolean} [isBinary] Value identifying whether the value is binary or not.
   * 
   * @private
   * @returns {void}
   */
  private #message(message: any, isBinary: boolean): void {
    if (Array.isArray(message)) message = Buffer.concat(message);
    else if (message instanceof ArrayBuffer) message = Buffer.from(message);
    
    message = JSON.parse(message);
    if (!('op' in message) || !(message.op.toLowerCase() in this.handlers)) return;
    this.handlers[message.op.toLowerCase()](this, message);
  }
  
  /**
   * This function is the part of loading all the handlers of requests made via websocket.
   * @private
   * @returns {object}
   */
  private async #resolveHandlers(): object {
    let handlers = {};
    for (let file of readdirSync(resolve(__dirname, 'handlers'))) {
      if (!file.endsWith('.js')) continue;
      let handler = (await import(`./handlers/${file}`)).default;
      handlers[file.split('.')[0].toLowerCase()] = handler;
    }
    
    return handlers;
  }
  
  /**
   * This function does the part of pinging websocket clients.
   * @return {object}
   */
  public startIntervalPing(): object {
    return setInterval(() =>
      this.clients.forEach(client => {
        if (!client.isAlive) return client.terminate();
        
        client.isAlive = false;
        return client.ping();
      })
    , 3e4); // 30 seconds
  }
}

export default WebsocketManager;